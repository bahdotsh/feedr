use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};

/// Main configuration structure for Feedr
#[derive(Clone, Debug, Serialize, Deserialize, Default)]
pub struct Config {
    #[serde(default)]
    pub general: GeneralConfig,
    #[serde(default)]
    pub network: NetworkConfig,
    #[serde(default)]
    pub ui: UiConfig,
    #[serde(default)]
    pub default_feeds: Vec<DefaultFeed>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct GeneralConfig {
    /// Maximum number of items to show on the dashboard
    #[serde(default = "default_max_dashboard_items")]
    pub max_dashboard_items: usize,
    /// Auto-refresh interval in seconds (0 = disabled)
    #[serde(default)]
    pub auto_refresh_interval: u64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NetworkConfig {
    /// HTTP request timeout in seconds
    #[serde(default = "default_http_timeout")]
    pub http_timeout: u64,
    /// User agent string for HTTP requests
    #[serde(default = "default_user_agent")]
    pub user_agent: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UiConfig {
    /// Tick rate for UI updates in milliseconds
    #[serde(default = "default_tick_rate")]
    pub tick_rate: u64,
    /// Error message display timeout in milliseconds
    #[serde(default = "default_error_timeout")]
    pub error_display_timeout: u64,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct DefaultFeed {
    pub url: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub category: Option<String>,
}

// Default value functions
fn default_max_dashboard_items() -> usize {
    100
}

fn default_http_timeout() -> u64 {
    15
}

fn default_user_agent() -> String {
    "Mozilla/5.0 (compatible; Feedr/1.0; +https://github.com/bahdotsh/feedr)".to_string()
}

fn default_tick_rate() -> u64 {
    100
}

fn default_error_timeout() -> u64 {
    3000
}

impl Default for GeneralConfig {
    fn default() -> Self {
        Self {
            max_dashboard_items: default_max_dashboard_items(),
            auto_refresh_interval: 0,
        }
    }
}

impl Default for NetworkConfig {
    fn default() -> Self {
        Self {
            http_timeout: default_http_timeout(),
            user_agent: default_user_agent(),
        }
    }
}

impl Default for UiConfig {
    fn default() -> Self {
        Self {
            tick_rate: default_tick_rate(),
            error_display_timeout: default_error_timeout(),
        }
    }
}

impl Config {
    /// Load configuration from the XDG config directory
    /// Falls back to default configuration if file doesn't exist
    pub fn load() -> Result<Self> {
        let config_path = Self::config_path();

        if config_path.exists() {
            let contents =
                fs::read_to_string(&config_path).context("Failed to read config file")?;

            let config: Config =
                toml::from_str(&contents).context("Failed to parse config file")?;

            Ok(config)
        } else {
            // Config doesn't exist, create it with defaults
            let config = Config::default();

            // Try to save the default config for future use
            if let Err(e) = config.save() {
                // Don't fail if we can't save, just use defaults
                eprintln!("Warning: Could not create default config file: {}", e);
            }

            Ok(config)
        }
    }

    /// Save configuration to the XDG config directory
    pub fn save(&self) -> Result<()> {
        let config_path = Self::config_path();

        // Ensure the parent directory exists
        if let Some(parent) = config_path.parent() {
            fs::create_dir_all(parent).context("Failed to create config directory")?;
        }

        let toml_string = toml::to_string_pretty(self).context("Failed to serialize config")?;

        // Add helpful comments to the config file
        let commented_config = Self::add_comments(&toml_string);

        fs::write(&config_path, commented_config).context("Failed to write config file")?;

        Ok(())
    }

    /// Get the path to the config file following XDG specifications
    pub fn config_path() -> PathBuf {
        let mut path = dirs::config_dir().unwrap_or_else(|| Path::new(".").to_path_buf());
        path.push("feedr");
        path.push("config.toml");
        path
    }

    /// Add helpful comments to the generated TOML config
    fn add_comments(toml: &str) -> String {
        format!(
            "# Feedr Configuration File\n\
             # This file is automatically generated with default values.\n\
             # You can modify any settings below to customize Feedr's behavior.\n\
             #\n\
             # For more information, visit: https://github.com/bahdotsh/feedr\n\
             \n\
             {}\n\
             \n\
             # Example default feeds configuration:\n\
             # [[default_feeds]]\n\
             # url = \"https://example.com/feed.xml\"\n\
             # category = \"News\"\n\
             #\n\
             # [[default_feeds]]\n\
             # url = \"https://another-example.com/rss\"\n\
             # category = \"Tech\"\n",
            toml
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = Config::default();
        assert_eq!(config.general.max_dashboard_items, 100);
        assert_eq!(config.network.http_timeout, 15);
        assert_eq!(config.ui.tick_rate, 100);
        assert_eq!(config.ui.error_display_timeout, 3000);
    }

    #[test]
    fn test_config_serialization() {
        let config = Config::default();
        let toml_str = toml::to_string(&config).unwrap();
        let deserialized: Config = toml::from_str(&toml_str).unwrap();

        assert_eq!(
            config.general.max_dashboard_items,
            deserialized.general.max_dashboard_items
        );
        assert_eq!(
            config.network.http_timeout,
            deserialized.network.http_timeout
        );
    }
}
